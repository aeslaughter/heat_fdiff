<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>1-D Snow Finite Difference: include/heat_fdiff.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<script src="http://www.mathjax.org/mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">1-D Snow Finite Difference&#160;<span id="projectnumber">0.1</span></div>
   <div id="projectbrief">C++ implementation of a 1-D finite difference solution of the heat equation applied to snow.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('heat__fdiff_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">include/heat_fdiff.cpp</div>  </div>
</div>
<div class="contents">
<a href="heat__fdiff_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00007"></a>00007 <span class="comment">// Add standard files</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;iostream.h&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;math.h&gt;</span> 
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">// Add the PETsc related files</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;petscvec.h&quot;</span>     <span class="comment">// PETsc vectors</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;petscmat.h&quot;</span>     <span class="comment">// PETsc matrices</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;petscksp.h&quot;</span>     <span class="comment">// PETsc KSP solver</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="comment">// Add the solution and snow related files</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="heat__fdiff_8h.html" title="Header file for heat_fdiff.cpp with code for solving the 1-D heat equatin in parallel.">heat_fdiff.h</a>&quot;</span>   <span class="comment">// Tools for solving 1-D heat equation</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">// Computes the a,b,c,d coefficents defined by Slaughter (2010)</span>
<a name="l00020"></a><a class="code" href="heat__fdiff_8h.html#a8b11119f3eac571761481a27e67dad06">00020</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#aa7af5bb5029eeac1555f9f5d52621b3d" title="Adds absorbed flux vector to the b vector of knowns.">get_coeff</a>(<span class="keywordtype">double</span> *c, <span class="keywordtype">double</span> rho, <span class="keywordtype">double</span> k, <span class="keywordtype">double</span> cp, <span class="keywordtype">double</span> dz, <span class="keywordtype">double</span> dt)
<a name="l00021"></a>00021 {
<a name="l00022"></a>00022                           c[0] = k/pow(dz,2);                    <span class="comment">// a</span>
<a name="l00023"></a>00023                           c[1] = (rho * cp)/dt;     <span class="comment">// b</span>
<a name="l00024"></a>00024                           c[2] = c[1] + c[0];                    <span class="comment">// c</span>
<a name="l00025"></a>00025                           c[3] = c[1] - c[0];                    <span class="comment">// d</span>
<a name="l00026"></a>00026                           <span class="keywordflow">return</span>(0);
<a name="l00027"></a>00027 }                         
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="comment">// Computes in parallel the vector of knowns using the ghosted temperature vector</span>
<a name="l00030"></a><a class="code" href="heat__fdiff_8h.html#ae3e0d9b122a1087d4895d26cddffbdce">00030</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#a9d3db9eb76d5d7c6ebc1b5f90f3e0707" title="Computes the vector of knowns without the absorbed heat flux.">bvec_update</a>(Vec *bvec, Vec *T, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> d, <span class="keywordtype">double</span> qs, <span class="keywordtype">double</span> Tbottom)
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032              <span class="keywordtype">int</span> i, r, np;                                       <span class="comment">// loop index, current process, total number of processes</span>
<a name="l00033"></a>00033              <span class="keywordtype">int</span> low, high;                                      <span class="comment">// indices storing the range of global indices for a local vector</span>
<a name="l00034"></a>00034              <span class="keywordtype">int</span> nlocal;                                         <span class="comment">// size of local array</span>
<a name="l00035"></a>00035              <span class="keywordtype">int</span> row = 0;                           <span class="comment">// index for inserting into PETsc vectors</span>
<a name="l00036"></a>00036              <span class="keywordtype">double</span> T123[3];                                     <span class="comment">// storage vector for temperatures {T(z-1), T(z), T(z+1)}</span>
<a name="l00037"></a>00037              <span class="keywordtype">double</span> val;                                         <span class="comment">// storage value for inserting into PETsc vectors</span>
<a name="l00038"></a>00038              <span class="keywordtype">double</span> *Tloc;                                       <span class="comment">// Pointer </span>
<a name="l00039"></a>00039              
<a name="l00040"></a>00040              <span class="comment">// Define the current process and the total number of processes               </span>
<a name="l00041"></a>00041              MPI_Comm_rank(MPI_COMM_WORLD, &amp;r);
<a name="l00042"></a>00042              MPI_Comm_size(MPI_COMM_WORLD, &amp;np);
<a name="l00043"></a>00043 
<a name="l00044"></a>00044              <span class="comment">// Extract the local values of the T vector into the Tloc array</span>
<a name="l00045"></a>00045              VecGetLocalSize(*T,&amp;nlocal);                                     <span class="comment">// Size of local vector</span>
<a name="l00046"></a>00046              VecGetOwnershipRange(*T, &amp;low, &amp;high); <span class="comment">// Global limits of the local vector</span>
<a name="l00047"></a>00047              VecGetArray(*T,&amp;Tloc);                                                        <span class="comment">// Extracts the local vector</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049              <span class="comment">// Loop through each value of the local vector and compute the b vector component</span>
<a name="l00050"></a>00050              <span class="keywordflow">for</span> (i=0; i&lt;nlocal; i++) {
<a name="l00051"></a>00051                           row = low + i;            <span class="comment">// Global index of the local component</span>
<a name="l00052"></a>00052              
<a name="l00053"></a>00053                           <span class="comment">// Case for the first value of b, b[0]</span>
<a name="l00054"></a>00054                           <span class="keywordflow">if</span>(r == 0 &amp;&amp; i == 0){                                                                      
<a name="l00055"></a>00055                                        T123[1] = Tloc[0];
<a name="l00056"></a>00056                                        T123[2] = Tloc[1];
<a name="l00057"></a>00057                                        val = d*T123[1] + a*T123[2] + 2*qs;    <span class="comment">// b[0]</span>
<a name="l00058"></a>00058                           } 
<a name="l00059"></a>00059                           
<a name="l00060"></a>00060                           <span class="comment">// Case for the last value of b vector</span>
<a name="l00061"></a>00061                           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == (np-1) &amp;&amp; i == (nlocal-1)){           
<a name="l00062"></a>00062                                        val = Tbottom;                                                                                          <span class="comment">// b[N-1], N = global vector size</span>
<a name="l00063"></a>00063                           }
<a name="l00064"></a>00064                           
<a name="l00065"></a>00065                           <span class="comment">// General cases middle values of gloval b vector (b[1] to b[N-2])</span>
<a name="l00066"></a>00066                           <span class="keywordflow">else</span> {                                                                                                                            
<a name="l00067"></a>00067                                        <span class="keywordflow">if</span> (i == 0){                                        <span class="comment">// case for first local entry</span>
<a name="l00068"></a>00068                                                     T123[0] = Tloc[nlocal];                <span class="comment">// 1st ghost (T[z-1])</span>
<a name="l00069"></a>00069                                                     T123[1] = Tloc[i];                                  <span class="comment">// T(z)</span>
<a name="l00070"></a>00070                                                     T123[2] = Tloc[i+1];                   <span class="comment">// T[z+1]</span>
<a name="l00071"></a>00071                                        }
<a name="l00072"></a>00072                                        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == (nlocal-1)){             <span class="comment">// case for middle local entries</span>
<a name="l00073"></a>00073                                                     T123[0] = Tloc[i-1];                   <span class="comment">// T[z-1]</span>
<a name="l00074"></a>00074                                                     T123[1] = Tloc[i];                                  <span class="comment">// T[z]</span>
<a name="l00075"></a>00075                                                     T123[2] = Tloc[nlocal+1]; <span class="comment">// T[z+1]</span>
<a name="l00076"></a>00076                                        }
<a name="l00077"></a>00077                                        <span class="keywordflow">else</span> {                                                                        <span class="comment">// case for last local entry</span>
<a name="l00078"></a>00078                                                     T123[0] = Tloc[i-1];                   <span class="comment">// T[z-1]</span>
<a name="l00079"></a>00079                                                     T123[1] = Tloc[i];                                  <span class="comment">// T[z]</span>
<a name="l00080"></a>00080                                                     T123[2] = Tloc[i+1];                   <span class="comment">// T[z+1]</span>
<a name="l00081"></a>00081                                        }
<a name="l00082"></a>00082                                        val = a/2*T123[0] + d*T123[1] + a/2*T123[2]; <span class="comment">// b value for general case</span>
<a name="l00083"></a>00083                           }            
<a name="l00084"></a>00084                           
<a name="l00085"></a>00085                           <span class="comment">// Insert the compute b vector value (all cases above)</span>
<a name="l00086"></a>00086                           VecSetValues(*bvec,1,&amp;row,&amp;val,INSERT_VALUES);
<a name="l00087"></a>00087              }
<a name="l00088"></a>00088              
<a name="l00089"></a>00089              <span class="comment">// Return the local array to the global temperature vector</span>
<a name="l00090"></a>00090              VecRestoreArray(*T,&amp;Tloc);
<a name="l00091"></a>00091              
<a name="l00092"></a>00092              <span class="comment">// Assemble the b vector</span>
<a name="l00093"></a>00093              VecAssemblyBegin(*bvec);
<a name="l00094"></a>00094              VecAssemblyEnd(*bvec);
<a name="l00095"></a>00095              <span class="keywordflow">return</span>(0);
<a name="l00096"></a>00096 }
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">// Adds the vector of absorbed heat flux to b vector of knowns</span>
<a name="l00099"></a><a class="code" href="heat__fdiff_8h.html#a5b7389e80da98ef839c3619138fe7cba">00099</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#a08e10602b73b5074158955ce6a876e37" title="Adds absorbed flux vector to the b vector of knowns.">bvec_applyflux</a>(Vec *bvec, Vec *qabs)
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101              <span class="comment">// Perform addition of vectors</span>
<a name="l00102"></a>00102              <span class="keywordtype">int</span> a = 1;                                                       <span class="comment">// multiplier</span>
<a name="l00103"></a>00103              VecAXPY(*bvec, a, *qabs); <span class="comment">// y = y + a*x</span>
<a name="l00104"></a>00104              
<a name="l00105"></a>00105              <span class="comment">// Assemble the new b vector</span>
<a name="l00106"></a>00106              VecAssemblyBegin(*bvec);
<a name="l00107"></a>00107              VecAssemblyEnd(*bvec);
<a name="l00108"></a>00108              <span class="keywordflow">return</span>(0);
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">// Assemble the global stiffness matrix in parallel</span>
<a name="l00112"></a><a class="code" href="heat__fdiff_8h.html#a2a071632696ac3101e89642c1c551bbd">00112</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#a94e3a5b97e4b2b983a57345a1713df6e" title="Builds or updates the stiffness matrix.">Kmat_update</a>(Mat *A,<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> c)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114 
<a name="l00115"></a>00115              <span class="comment">//  Define the variables</span>
<a name="l00116"></a>00116              <span class="keywordtype">int</span> i, j;                              <span class="comment">// row loop index, column index,</span>
<a name="l00117"></a>00117              <span class="keywordtype">int</span> r, N;                              <span class="comment">// current process, dimension of matrix (N x N_</span>
<a name="l00118"></a>00118              <span class="keywordtype">int</span> low, high;                         <span class="comment">// indices storing the range of global indices for a local vector</span>
<a name="l00119"></a>00119              <span class="keywordtype">double</span> val;                            <span class="comment">// storage value for inserting into PETsc matrix object</span>
<a name="l00120"></a>00120              
<a name="l00121"></a>00121              <span class="comment">// Initize necessary variables</span>
<a name="l00122"></a>00122              MatGetSize(*A,&amp;N,&amp;N);                                                         <span class="comment">// global size of the stiffnexx matrix</span>
<a name="l00123"></a>00123              MPI_Comm_rank(MPI_COMM_WORLD, &amp;r);                  <span class="comment">// the current process</span>
<a name="l00124"></a>00124              MatZeroEntries(*A);                                                                        <span class="comment">// zero out the stiffness matrix</span>
<a name="l00125"></a>00125              MatGetOwnershipRange(*A, &amp;low, &amp;high); <span class="comment">// global index range of the local matrix</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127              <span class="comment">// Loop through each row of the local stiffness matrix</span>
<a name="l00128"></a>00128              <span class="keywordflow">for</span>(i = low; i &lt; high; ++i) {
<a name="l00129"></a>00129                           <span class="comment">// Case for the first row: A[0,0] and A[0,1]</span>
<a name="l00130"></a>00130                           <span class="keywordflow">if</span>(i == 0){
<a name="l00131"></a>00131                                        MatSetValues(*A,1,&amp;i,1,&amp;i,&amp;c,ADD_VALUES);           <span class="comment">// A[0,0]</span>
<a name="l00132"></a>00132                                        j = 1;
<a name="l00133"></a>00133                                        val = -a;
<a name="l00134"></a>00134                                        MatSetValues(*A,1,&amp;i,1,&amp;j,&amp;val,ADD_VALUES); <span class="comment">// A[0,1]</span>
<a name="l00135"></a>00135                           }
<a name="l00136"></a>00136                           
<a name="l00137"></a>00137                           <span class="comment">// Case for the end of the matrix: A[N-1,N-1]</span>
<a name="l00138"></a>00138                           <span class="keywordflow">else</span> <span class="keywordflow">if</span>(i == (N - 1)){
<a name="l00139"></a>00139                                        val = 1.0;
<a name="l00140"></a>00140                                        MatSetValues(*A,1,&amp;i,1,&amp;i,&amp;val,ADD_VALUES);
<a name="l00141"></a>00141              
<a name="l00142"></a>00142                           }
<a name="l00143"></a>00143                           
<a name="l00144"></a>00144                           <span class="comment">// General case, diagonal terms</span>
<a name="l00145"></a>00145                           <span class="keywordflow">else</span>{
<a name="l00146"></a>00146                                        MatSetValues(*A,1,&amp;i,1,&amp;i,&amp;c,ADD_VALUES);           <span class="comment">// A[i,i]</span>
<a name="l00147"></a>00147                                        j = i - 1;
<a name="l00148"></a>00148                                        val = -a/2;
<a name="l00149"></a>00149                                        MatSetValues(*A,1,&amp;i,1,&amp;j,&amp;val,ADD_VALUES);         <span class="comment">// A[i,i-1]</span>
<a name="l00150"></a>00150                                        j = i + 1;
<a name="l00151"></a>00151                                        MatSetValues(*A,1,&amp;i,1,&amp;j,&amp;val,ADD_VALUES); <span class="comment">// A[i,i+1]</span>
<a name="l00152"></a>00152                           }
<a name="l00153"></a>00153              }
<a name="l00154"></a>00154              
<a name="l00155"></a>00155              <span class="comment">// Assemble the stiffness matrix</span>
<a name="l00156"></a>00156              MatAssemblyBegin(*A,MAT_FINAL_ASSEMBLY);
<a name="l00157"></a>00157              MatAssemblyEnd  (*A,MAT_FINAL_ASSEMBLY);
<a name="l00158"></a>00158              <span class="keywordflow">return</span>(0);
<a name="l00159"></a>00159 }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">// Solves for the current temperature vector (x) given K and b: Ax = b </span>
<a name="l00162"></a><a class="code" href="heat__fdiff_8h.html#af3bd554cb7812c74be552485ce8f31f1">00162</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#a5f35d50933e63e6738c7555ed8d9a9df" title="Solves the linear equation, Ax = b, for x in parallel.">solve_temp</a>(Vec *T, Vec *bvec, Mat *A)
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164              <span class="comment">// Define variables</span>
<a name="l00165"></a>00165              <span class="keywordtype">int</span> N;                    <span class="comment">// N = size of global vector</span>
<a name="l00166"></a>00166              Vec Tnew;    <span class="comment">// PETsc vector for storing the computed temperatures (x)</span>
<a name="l00167"></a>00167              
<a name="l00168"></a>00168              <span class="comment">// Determine the global vector size</span>
<a name="l00169"></a>00169              VecGetSize(*T,&amp;N);
<a name="l00170"></a>00170              
<a name="l00171"></a>00171              <span class="comment">// Create the parallel Tnew vector</span>
<a name="l00172"></a>00172              VecCreateMPI(PETSC_COMM_WORLD,PETSC_DETERMINE,N,&amp;Tnew);
<a name="l00173"></a>00173              
<a name="l00174"></a>00174              <span class="comment">// Define and solve the linear equations (see PETsc manual)</span>
<a name="l00175"></a>00175              KSP ksp;                                                                                   <span class="comment">// Identifies KSP solution variable</span>
<a name="l00176"></a>00176              KSPCreate(PETSC_COMM_WORLD,&amp;ksp);      <span class="comment">// Creates the KSP solution object</span>
<a name="l00177"></a>00177              
<a name="l00178"></a>00178              <span class="comment">// Set tolerances</span>
<a name="l00179"></a>00179              KSPSetTolerances(ksp,PETSC_DEFAULT, PETSC_DEFAULT, 
<a name="l00180"></a>00180                           PETSC_DEFAULT, PETSC_DEFAULT); 
<a name="l00181"></a>00181              KSPSetFromOptions(ksp);                                          
<a name="l00182"></a>00182              
<a name="l00183"></a>00183              <span class="comment">// Assigns A matrix to solver</span>
<a name="l00184"></a>00184              KSPSetOperators(ksp,*A,*A,DIFFERENT_NONZERO_PATTERN); 
<a name="l00185"></a>00185              
<a name="l00186"></a>00186              <span class="comment">// Solves the equation and outputs to Tnew</span>
<a name="l00187"></a>00187              KSPSolve(ksp,*bvec,Tnew);                                                     
<a name="l00188"></a>00188              
<a name="l00189"></a>00189              <span class="comment">// Assign Tnew = T for the next time step</span>
<a name="l00190"></a>00190              VecCopy(Tnew,*T);
<a name="l00191"></a>00191              
<a name="l00192"></a>00192              <span class="comment">// Destroy Tnew vector and zero out b vector and stiffness matrix</span>
<a name="l00193"></a>00193              VecDestroy(Tnew);
<a name="l00194"></a>00194              VecZeroEntries(*bvec);
<a name="l00195"></a>00195              MatZeroEntries(*A);
<a name="l00196"></a>00196              <span class="keywordflow">return</span>(0);
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="comment">// Create a temperature vector with ghosted values</span>
<a name="l00200"></a><a class="code" href="heat__fdiff_8h.html#a2aa45f63f2717c48d216450ba08ba357">00200</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#aaadc8b94dffbc94aa188607872411dfb" title="Creates a parallel vector with padding or ghosted values.">createWithGhosts</a>(Vec *x, <span class="keywordtype">int</span> N)
<a name="l00201"></a>00201 {
<a name="l00202"></a>00202              <span class="comment">// Define variables</span>
<a name="l00203"></a>00203              <span class="keywordtype">int</span> nlocal;  <span class="comment">// local size of vector</span>
<a name="l00204"></a>00204              <span class="keywordtype">int</span> gidx[2];              <span class="comment">// global indices for ghosts</span>
<a name="l00205"></a>00205              <span class="keywordtype">int</span> r;                                 <span class="comment">// current process number</span>
<a name="l00206"></a>00206              <span class="keywordtype">int</span> np;                   <span class="comment">// total number of processes </span>
<a name="l00207"></a>00207                           
<a name="l00208"></a>00208              <span class="comment">// Determine process and total number of processors</span>
<a name="l00209"></a>00209              MPI_Comm_rank(MPI_COMM_WORLD, &amp;r);     
<a name="l00210"></a>00210              MPI_Comm_size(MPI_COMM_WORLD, &amp;np);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212              <span class="comment">// Return and error if the number of processes exceeds the length of vector</span>
<a name="l00213"></a>00213              <span class="keywordflow">if</span>(np &gt; N){
<a name="l00214"></a>00214                           SETERRQ(1,<span class="stringliteral">&quot;The number of processors must not exceed the vectors size!&quot;</span>);
<a name="l00215"></a>00215              }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217              <span class="comment">// Calculate the desired number of local values per processes</span>
<a name="l00218"></a>00218              nlocal = ceil(<span class="keywordtype">double</span>(N)/<span class="keywordtype">double</span>(np));
<a name="l00219"></a>00219 
<a name="l00220"></a>00220              <span class="comment">// Define the global indices for the ghosts</span>
<a name="l00221"></a>00221              <span class="comment">// Case for first process</span>
<a name="l00222"></a>00222              <span class="keywordflow">if</span>(r == 0){ 
<a name="l00223"></a>00223                           gidx[0] = 0; gidx[1] = nlocal;
<a name="l00224"></a>00224              } 
<a name="l00225"></a>00225              
<a name="l00226"></a>00226              <span class="comment">// Case for the last process</span>
<a name="l00227"></a>00227              <span class="keywordflow">else</span> <span class="keywordflow">if</span>(r == (np - 1)){
<a name="l00228"></a>00228                           gidx[0] = (r * nlocal) - 1; 
<a name="l00229"></a>00229                           gidx[1] = N - 1;
<a name="l00230"></a>00230                           nlocal = N - r * nlocal;
<a name="l00231"></a>00231              }
<a name="l00232"></a>00232              
<a name="l00233"></a>00233              <span class="comment">// Case for the middle processes</span>
<a name="l00234"></a>00234              <span class="keywordflow">else</span>{
<a name="l00235"></a>00235                           gidx[0] = (r * nlocal) - 1;            
<a name="l00236"></a>00236                           gidx[1] = ((r + 1) * nlocal);          
<a name="l00237"></a>00237              }            
<a name="l00238"></a>00238              
<a name="l00239"></a>00239              <span class="comment">// Create the ghosted vector</span>
<a name="l00240"></a>00240              VecCreateGhost(PETSC_COMM_WORLD,nlocal,PETSC_DECIDE,2,gidx,x);
<a name="l00241"></a>00241              <span class="keywordflow">return</span>(0);
<a name="l00242"></a>00242 };
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="comment">// Assembles the ghosted vector</span>
<a name="l00245"></a><a class="code" href="heat__fdiff_8h.html#ac4a479082951e70be649dc5a95c5d550">00245</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#ad53d011533aef5ba6c74a707770d8cf4" title="Assembles a ghosted PETsc vector created with the function createWithGhosts.">assembleVec</a>(Vec *x)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247              <span class="comment">// Assembles the vector</span>
<a name="l00248"></a>00248              VecAssemblyBegin(*x);
<a name="l00249"></a>00249              VecAssemblyEnd(*x);
<a name="l00250"></a>00250              
<a name="l00251"></a>00251              <span class="comment">// Updates the ghost values</span>
<a name="l00252"></a>00252              VecGhostUpdateBegin(*x,INSERT_VALUES,SCATTER_FORWARD);
<a name="l00253"></a>00253              VecGhostUpdateEnd(*x,INSERT_VALUES,SCATTER_FORWARD);
<a name="l00254"></a>00254              
<a name="l00255"></a>00255              <span class="keywordflow">return</span>(0);
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="comment">// Appends the temperature vector to a file</span>
<a name="l00259"></a><a class="code" href="heat__fdiff_8h.html#ab8cf1d914e52c1c70f36a4430ecdeefa">00259</a> <span class="keywordtype">int</span> <a class="code" href="heat__fdiff_8cpp.html#afdfdc9e7147e46ae84f6a19b2ea9c1b2" title="Outputs a temperature vector to a file.">output_temp</a>(Vec *T, <span class="keywordtype">int</span> init, <span class="keywordtype">char</span> *filename, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> dz, <span class="keywordtype">int</span> nt, <span class="keywordtype">double</span> dt)
<a name="l00260"></a>00260 {
<a name="l00261"></a>00261              <span class="comment">// Define variables</span>
<a name="l00262"></a>00262              <span class="keywordtype">int</span> r;                                 <span class="comment">// current process</span>
<a name="l00263"></a>00263              <span class="keywordtype">double</span> Tout; <span class="comment">// temperature to output</span>
<a name="l00264"></a>00264              <span class="keywordtype">int</span> k = 0;                <span class="comment">// loop index</span>
<a name="l00265"></a>00265              
<a name="l00266"></a>00266              <span class="comment">// Determine the current process</span>
<a name="l00267"></a>00267              MPI_Comm_rank(MPI_COMM_WORLD, &amp;r);
<a name="l00268"></a>00268              
<a name="l00269"></a>00269              <span class="comment">// Utilze the first process for creating the output file</span>
<a name="l00270"></a>00270              <span class="keywordflow">if</span>( r == 0 ){
<a name="l00271"></a>00271                           <span class="comment">// Define file and open the file for appending</span>
<a name="l00272"></a>00272                           FILE * fid;
<a name="l00273"></a>00273                           fid = fopen(filename,<span class="stringliteral">&quot;a&quot;</span>);
<a name="l00274"></a>00274                           
<a name="l00275"></a>00275                           <span class="comment">// Write the numerial solution information if the init flag is zero</span>
<a name="l00276"></a>00276                           <span class="keywordflow">if</span>(init == 0){
<a name="l00277"></a>00277                                        fprintf(fid, <span class="stringliteral">&quot;n = %i\n&quot;</span>,n);                                      <span class="comment">// The number of layers </span>
<a name="l00278"></a>00278                                        fprintf(fid, <span class="stringliteral">&quot;dz = %f\n&quot;</span>,dz);                                    <span class="comment">// The layer thickness (m)</span>
<a name="l00279"></a>00279                                        fprintf(fid, <span class="stringliteral">&quot;nt = %i\n&quot;</span>,nt);                                    <span class="comment">// Number of time steps</span>
<a name="l00280"></a>00280                                        fprintf(fid, <span class="stringliteral">&quot;dt = %f\n&quot;</span>,dt);                                    <span class="comment">// Time step (sec)</span>
<a name="l00281"></a>00281                           }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283                           <span class="comment">// Write the temperature data</span>
<a name="l00284"></a>00284                           <span class="keywordflow">for</span>(k=0; k&lt;=n-1; k++){
<a name="l00285"></a>00285                                        VecGetValues(*T,1,&amp;k,&amp;Tout);
<a name="l00286"></a>00286                                        fprintf(fid,<span class="stringliteral">&quot;%g\n&quot;</span>,Tout);
<a name="l00287"></a>00287                           }
<a name="l00288"></a>00288                           fclose(fid);
<a name="l00289"></a>00289              }
<a name="l00290"></a>00290              <span class="keywordflow">return</span>(0);
<a name="l00291"></a>00291 }
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="heat__fdiff_8cpp.html">heat_fdiff.cpp</a>      </li>
      <li class="footer">Generated on Thu Jun 21 2012 20:53:45 for 1-D Snow Finite Difference by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
